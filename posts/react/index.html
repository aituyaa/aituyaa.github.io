<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="React - https://loveminimal.github.io/posts/react/">
    <meta name="author" content="Jack - https://loveminimal.github.io/">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>React</title>
    <link rel="icon" type="image/png" href="/favicon.ico">
    
    <link rel="stylesheet" href="https://loveminimal.github.io/style.min.588bdbe244863f48f211eae6ac79640e39689f34e9568c6f2789c5519ab60956.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate ">
        <div id="header"><div class="container-header">
    <div id="vars" class="container-vars" style="display: none;">
	{
		"isSingleColumnOfPostList": true,
		"hasFoldAllCodeBlocks": false,
		"svgColor": "",
		"en": false,
		"dark": false
	}
</div>
    <h1 class="title">
        
            React
            
        
    </h1>

    <div class="container-breadcrumb-nav">
    
    <div class="breadcrumb-nav-bar">
        <div><a href="/"><svg t="1656411084410" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2954" width="16" height="16"><path d="M947.5 390.6l-377-290c-34.5-26.5-82.6-26.5-117.1 0l-377 290c-14 10.8-16.6 30.9-5.9 44.9 10.8 14 30.9 16.6 44.9 5.9l28.5-21.9V768c0 88.2 71.8 160 160 160h80c35.3 0 64-28.7 64-64V640c0-17.6 14.4-32 32-32h64c17.6 0 32 14.4 32 32v224c0 35.3 28.7 64 64 64h80c88.2 0 160-71.8 160-160V419.4l28.5 21.9c5.8 4.5 12.7 6.6 19.5 6.6 9.6 0 19.1-4.3 25.4-12.5 10.8-13.9 8.2-34-5.8-44.8zM816 768c0 52.9-43.1 96-96 96h-80V640c0-52.9-43.1-96-96-96h-64c-52.9 0-96 43.1-96 96v224h-80c-52.9 0-96-43.1-96-96V370.2l284.5-218.8c11.5-8.8 27.5-8.8 39 0L816 370.2V768z" fill="#6c757d" p-id="2955"></path></svg></a></div>
        <div><a href="/nav"><svg t="1656411531924" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5827" width="16" height="16"><path d="M849.59197473 125.23018519L139.22930586 391.72854662a23.35052669 23.35052669 0 0 0-14.95414244 21.65490745c-0.12257519 9.70384955 5.61801843 18.46795771 14.40255493 22.04306141l318.42928099 129.25528056 119.51057092 320.39047893c3.06437293 8.23295069 10.35758221 13.89182751 18.7335381 14.87242563l2.7170774 0.14300521a22.79893918 22.79893918 0 0 0 21.20546682-15.36272638l259.51158924-729.54564933a23.8612558 23.8612558 0 0 0-5.31158128-24.55584682 22.3290685 22.3290685 0 0 0-23.9021142-5.43415649zM793.65694081 211.64552314l-196.63064161 552.75171747-91.91077952-246.37564122-253.62799211-102.96295445 542.16941324-203.4131218z" p-id="5828" fill="#6c757d"></path></svg></a></div>
        <div><a href="/search"><svg t="1656411627509" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1730" width="14" height="14"><path d="M469.333333 85.333333c211.968 0 384 172.032 384 384s-172.032 384-384 384-384-172.032-384-384 172.032-384 384-384z m0 682.666667c164.992 0 298.666667-133.674667 298.666667-298.666667 0-165.034667-133.674667-298.666667-298.666667-298.666666-165.034667 0-298.666667 133.632-298.666666 298.666666 0 164.992 133.632 298.666667 298.666666 298.666667z m362.026667 3.029333l120.704 120.661334-60.373333 60.373333-120.661334-120.704 60.330667-60.330667z" p-id="1731" fill="#6c757d"></path></svg></a></div>
        <div><a href="/posts"><svg t="1656411724198" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5655" width="12" height="12"><path d="M811.705761 1024H212.294239c-93.1199 0-174.823046-87.570975-174.823046-187.387854V162.322018C37.471193 69.776145 112.604921 0 212.294239 0H596.190595l7.015883 5.93161c111.74388 95.479788 185.857116 170.741078 279.614824 266.093304 29.65805 30.040735 61.165743 62.122454 96.436499 97.393211l7.271006 7.334787v459.859234c-0.063781 99.816879-81.703145 187.387854-174.823046 187.387854zM212.294239 49.94033c-72.391155 0-124.882716 47.261538-124.882716 112.381688v674.290128c0 71.94469 59.507443 137.383743 124.882716 137.383743h599.411522c65.311492 0 124.882716-65.439053 124.882716-137.383743V397.417876c-32.528184-32.464404-61.73977-62.250016-89.356836-90.377328-90.951355-92.418312-163.278729-165.957521-269.601245-257.163999H212.294239z" fill="#6c757d" p-id="5656"></path><path d="M936.588477 449.526752h-212.326129c-99.753099 0-187.324073-81.703145-187.324073-174.823046V49.94033a25.002055 25.002055 0 0 1 49.94033 0v224.763376c0 65.311492 65.502834 124.882716 137.383743 124.882716h212.326129a25.002055 25.002055 0 1 1 0 49.94033z" fill="#6c757d" p-id="5657"></path></svg></a></div>
        <div><a href="/archive"><svg t="1656411795742" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7334" width="12" height="12"><path d="M884.224 522.24H504.32V141.824c0-16.896-13.824-30.72-30.72-30.72-120.32 0-233.472 47.616-317.952 134.144S26.112 445.952 29.184 566.784c2.56 114.688 49.152 222.72 131.072 304.128 81.92 81.408 189.952 128 304.64 130.56h10.24c117.76 0 227.84-45.568 312.32-128.512 86.528-85.504 133.632-199.68 132.608-321.024-0.512-2.048-1.536-29.696-35.84-29.696z m-140.288 307.712c-74.752 73.728-173.056 112.64-277.504 110.592-205.824-4.608-370.688-169.472-375.296-374.784-3.072-104.448 35.84-202.752 108.544-277.504 65.536-67.072 151.552-107.52 243.712-114.688v378.88c0 16.896 13.824 30.72 30.72 30.72 129.024 0 311.296 0 382.976 0.512-6.144 93.184-46.08 179.712-113.152 246.272z" fill="#6c757d" p-id="7335"></path><path d="M603.136 11.264c-8.192-0.512-15.872 3.072-22.016 8.704-5.632 5.632-9.216 13.824-9.216 22.016v378.88c0 16.896 13.824 30.72 30.72 30.72h378.88c16.896 0 30.72-13.824 30.72-30.72 0-223.744-183.808-407.552-409.088-409.6z m30.208 378.88V74.24c167.424 16.384 301.056 150.016 315.904 315.904h-315.904z" fill="#6c757d" p-id="7336"></path></svg></a></div>
        <div id="light-dark" style="cursor: pointer;"><a><svg t="1656411842215" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5086" width="12" height="12"><path d="M1007.492874 384.513055c-8.795694-34.58307-21.189627-67.666874-36.682043-99.05151-2.698679-5.397358-10.894667-3.498287-10.894666 2.598728v0.299853c0 32.484098-6.896624 63.868734-19.890263 92.554691-10.694764 23.488501-25.487523 45.077933-43.978471 64.068635-41.779547 42.679107-99.05151 66.967217-158.722299 67.26707-61.869712 0.299853-119.941284-24.188159-162.920244-68.966238-40.280281-41.979449-62.56937-98.251902-62.269516-156.323473 0.399804-59.270984 23.588452-114.94373 65.567901-156.823229 19.59041-19.59041 42.179351-35.082826 66.667364-46.077443C672.956643 71.166451 704.041426 64.469729 736.125719 64.469729h1.299364c6.097015 0 8.096037-8.096037 2.598728-10.794715C708.739126 37.982696 675.655322 25.488812 641.172203 16.493216 599.492607 5.598549 555.714038-0.098662 510.536154 0.001289 222.37722 0.700947-7.41029 237.38508 0.185992 525.444064c7.096526 271.667008 225.889418 490.559851 497.456474 497.856279 287.559228 7.796183 524.14341-220.891864 525.842579-508.551044 0.299853-44.977981-5.297407-88.656599-15.992171-130.236244z m-83.15929 301.552378c-22.588942 53.27392-54.873137 101.250434-95.953027 142.330323-41.179841 41.179841-89.056403 73.464036-142.330324 95.953027-55.172991 23.288599-113.744317 35.182777-174.314666 35.182777s-119.141675-11.794226-174.314666-35.182777c-53.27392-22.588942-101.250434-54.873137-142.330323-95.953027-41.179841-41.179841-73.464036-89.056403-95.953027-142.330323C75.749001 630.892442 63.954774 572.221164 63.954774 511.750767s11.794226-119.141675 35.182777-174.314666c22.588942-53.27392 54.873137-101.250434 95.953027-142.330323 41.179841-41.179841 89.056403-73.464036 142.330323-95.953027C392.593892 75.7642 451.26517 63.969974 511.735567 63.969974c13.99315 0 27.886348 0.599706 41.679596 1.89907C489.246577 118.643209 448.266638 198.704016 448.266638 288.360126c0 159.022152 128.836929 287.859081 287.859081 287.859081 89.156354 0 168.817357-40.580134 221.691473-104.149015 1.099462 13.09359 1.699168 26.387082 1.699168 39.680575 0 60.470397-11.794226 119.141675-35.182776 174.314666z" p-id="5087" fill="#6c757d"></path></svg></a></div>
        
    </div>

    
</div>

            <div id="toc">📜</div>
        
    
    
</div>
</div>
        <div id="content">















<div class="container-main 
     container-page 
">

    <div class="desc">
        
        <span>
            
            <svg t="1656736000388" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7409" width="12" height="12"><path d="M524.885333 338.986667L200.362667 663.466667c-17.28 15.274667-27.989333 36.693333-29.696 56.234666v133.76l130.730666 0.085334c22.784-1.621333 43.989333-12.245333 61.013334-31.701334l322.688-322.645333-160.213334-160.213333z m60.373334-60.330667l160.170666 160.213333 102.144-102.144a19.712 19.712 0 0 0 0-27.861333L715.093333 176.426667a19.456 19.456 0 0 0-27.605333 0L585.258667 278.613333zM701.312 85.333333c27.946667 0 54.741333 11.136 74.282667 30.848l132.309333 132.309334a105.045333 105.045333 0 0 1 0 148.565333L424.874667 879.957333c-29.824 34.346667-72.106667 55.466667-120.448 58.794667H85.333333v-42.666667l0.128-179.84c3.626667-44.970667 24.576-86.826667 56.448-114.944l485.12-485.034666A104.789333 104.789333 0 0 1 701.269333 85.333333z" p-id="7410" fill="#adb5bd"></path></svg>
            2022-09-19&nbsp;
        </span>
        <span>
            
            <svg t="1656737270708" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23838" width="11" height="11"><path d="M824.264 95.36c0-23.859 25.043-44.16 48.902-44.16s49.714 20.301 49.714 44.16v190.08c0 23.859-19.054 52.868-42.913 52.868h-190.08c-23.859 0-46.696-25.96-46.696-49.819s22.55-46.249 46.409-46.249h82.025C702.344 175.534 610.22 155.853 512 155.853c-206.775 0-360.398 149.372-360.398 356.147 0 206.775 153.623 358.23 360.398 358.23 206.775 0 357.467-151.455 357.467-358.23 0-23.859 23.634-50.706 53.413-50.706 29.78 0 49.92 26.847 49.92 50.706 0 254.493-206.307 460.8-460.8 460.8-254.493 0-460.8-206.307-460.8-460.8C51.2 257.507 257.507 51.2 512 51.2c122.4 0 226.684 33.296 312.264 117.369 0.358 0.351 0.358-24.052 0-73.209z" p-id="23839" fill="#adb5bd"></path></svg>
            2023-05-08&nbsp;&nbsp;&nbsp;
        </span>
        <span>
            
            <svg t="1656737548689" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="33866" width="12" height="12"><path d="M832.038608 64.662657H192.030028C121.255125 64.662657 63.940169 121.98845 63.940169 192.694717v446.793671C63.940169 710.205493 121.255125 767.643272 192.030028 767.643272h133.353183a63.940169 63.940169 0 0 1 55.219742 31.576328l76.099638 129.83828c12.358154 21.093031 33.790754 31.626903 55.216129 31.626903s42.832688-10.544709 55.198067-31.619678l76.222461-129.870792a63.940169 63.940169 0 0 1 55.212517-31.551041h133.54103c70.576219 0 127.732228-57.289669 127.732227-127.800865V192.391272C959.825022 121.85479 902.643727 64.662657 832.038608 64.662657zM895.884854 639.842407A63.85347 63.85347 0 0 1 832.092795 703.703103h-133.54103a127.753903 127.753903 0 0 0-110.349172 63.09847l-76.222461 129.856342a0.274545 0.274545 0 0 1 0-0.050574h-0.032512s-0.021675 0.061411-0.032512 0.061412l-76.1466-129.85273A127.804477 127.804477 0 0 0 325.383211 703.703103H192.030028A64.207489 64.207489 0 0 1 127.880338 639.488388V192.694717A64.102729 64.102729 0 0 1 192.030028 128.602826h640.00858A63.799284 63.799284 0 0 1 895.884854 192.391272v447.451135z" fill="#adb5bd" p-id="33867"></path><path d="M608.154093 288.092004A31.970084 31.970084 0 0 0 576.184009 320.062089v160.078006l-134.650049-179.278119A31.970084 31.970084 0 0 0 384.002258 320.062089v255.760676a31.970084 31.970084 0 0 0 63.940169 0v-159.958796l134.650048 179.274507a31.970084 31.970084 0 0 0 57.531703-19.200113V320.062089a31.970084 31.970084 0 0 0-31.970085-31.970085z" fill="#adb5bd" p-id="33868"></path></svg>
            5794 字</span>&nbsp;
        <span>
            
            <svg t="1656737462334" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="32892" width="12" height="12"><path d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z" p-id="32893" fill="#adb5bd"></path><path d="M695.466667 567.466667l-151.466667-70.4V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666l170.666667 81.066667c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8 0 23.466667-6.4 29.866666-19.2 6.4-14.933333 0-34.133333-17.066666-42.666666z" p-id="32894" fill="#adb5bd"></path></svg>
            12 分钟</span>
            <div class="container-ctgtag">
	<div class="taxonomy">
		
		<div class="ctg">
			
			
			<a href="/categories/javascript">JavaScript</a>
			
		</div>
		<div class="tag">
			
			
			
		</div>
	</div>
</div>
        
    </div>
    
    <div class="toc">
        
        <div class="page-operation">
            <div><a href="#"><img src="/imgs/icons/arrow-up-circle.svg" alt=""></a></div>
            <div><a href="https://loveminimal.github.io/posts/canvas/"><img src="/imgs/icons/arrow-left-circle.svg" alt=""></a></div>
            <div><a href="https://loveminimal.github.io/posts/about-virgo/"><img src="/imgs/icons/arrow-right-circle.svg" alt=""></a></div>
        </div>
        
        <nav id="TableOfContents">
  <ul>
    <li><a href="#核心概念">核心概念</a>
      <ul>
        <li><a href="#jsx-简介">JSX 简介</a></li>
        <li><a href="#元素渲染">元素渲染</a></li>
        <li><a href="#组件--props">组件 &amp; Props</a></li>
        <li><a href="#state--生命周期">State &amp; 生命周期</a></li>
        <li><a href="#事件处理">事件处理</a></li>
        <li><a href="#条件渲染">条件渲染</a></li>
        <li><a href="#列表--key">列表 &amp; Key</a></li>
        <li><a href="#表单">表单</a></li>
        <li><a href="#状态提升">状态提升</a></li>
        <li><a href="#组合-vs-继承">组合 vs 继承</a></li>
        <li><a href="#react-哲学">React 哲学</a></li>
      </ul>
    </li>
    <li><a href="#hook">HOOK</a></li>
    <li><a href="#相关技术栈">相关技术栈</a>
      <ul>
        <li><a href="#样式">样式</a></li>
        <li><a href="#路由">路由</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>

    <div class='content  content '>
        <p><a href="%5Bhttps://%5D(https://react.docschina.org/docs/getting-started.html)">📔 官方文档</a></p>
<blockquote>
<p>具体安装及引入细节，请直接参考官方文档。</p>
</blockquote>
<p>React 是一个用于构建用户界面的 JavaScript 库，你可以用它给简单的 HTML 页面增加一点交互，也可以开始一个完全由 React 驱动的复杂应用。</p>
<p><code>&gt; 对的，它只是一个 UI 库而已 ！！！</code></p>
<p>简单的就不说了，直接来看一下 React 团队推荐的创建 SPA （单页面，Single Page App）的工具链 - <a href="https://react.docschina.org/docs/create-a-new-react-app.html#create-react-app">Create React App</a> 。</p>
<p>要创建项目，请执行：</p>
<pre tabindex="0"><code>npx create-react-app my-app
cd my-app
npm start
</code></pre><p>Create React App 不会处理后端逻辑或操纵数据库；它只是创建一个前端构建流水线（build pipeline），所以你可以使用它来配合任何你想使用的后端。它在内部使用 Babel 和 webpack，但你无需了解它们的任何细节。当然，关于它，你肯定想了解更多，请参考 <a href="%5Bhttps://%5D(https://facebook.github.io/create-react-app/)">用户指南</a> 。</p>
<p>如果你倾向于从头开始打造你自己的 JavaScript 工具链，可以 <a href="https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658">查看这个指南</a>，它重新创建了一些 Create React App 的功能。</p>
<h2 id="核心概念">核心概念</h2>
<p>老规矩，上 <code>&quot;Hello World&quot;</code> 😂</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// &lt;div id=&#34;root&#34;&gt;&lt;/div&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> element <span style="color:#000;font-weight:bold">=</span> &lt;<span style="color:#000080">h1</span>&gt;Hello, world<span style="color:#000;font-weight:bold">!</span>&lt;/<span style="color:#000080">h1</span>&gt;;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReactDOM.render(
</span></span><span style="display:flex;"><span>  element,
</span></span><span style="display:flex;"><span>  <span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;root&#39;</span>)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>它将在页面上展示一个 “Hello, world!” 的标题。不要着急，马上你就明白它的工作原理了！</p>
<h3 id="jsx-简介">JSX 简介</h3>
<p>再观察一下上面的例子，这是什么？</p>
<pre tabindex="0"><code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
</code></pre><p><code>&gt; 怎么把 DOM 元素直接赋给了一个变量 ❓</code></p>
<p>这个有趣的标签语法既不是字符串也不是 HTML。它被称为 JSX，是一个 JavaScript 的语法扩展。</p>
<p>JSX 可以生成 React “元素”，它其实一个表达式，在编译（通过 Babel）之后，会被转为普通 JavaScript 函数（<code>React.createElement()</code>）调用，并且对其取值后得到 JavaScript 对象。</p>
<p>JSX 的语法格式十分简单！上 🌰</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> name <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;Josh Perez&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> element <span style="color:#000;font-weight:bold">=</span> (
</span></span><span style="display:flex;"><span>	&lt;<span style="color:#000080">h1</span>&gt;
</span></span><span style="display:flex;"><span>		Hello, {name}
</span></span><span style="display:flex;"><span>	&lt;/<span style="color:#000080">h1</span>&gt;
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> element <span style="color:#000;font-weight:bold">=</span> &lt;<span style="color:#000080">img</span> <span style="color:#008080">src</span><span style="color:#000;font-weight:bold">=</span>{user.avatarUrl}&gt;&lt;/<span style="color:#000080">img</span>&gt;;
</span></span></code></pre></div><p><strong>在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。</strong></p>
<p>只需要注意：</p>
<ul>
<li>尽量将内容包裹在括号中，以避免多行书写时遇到自动插入分号陷阱；</li>
<li>在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号；</li>
<li>使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</li>
</ul>
<p>OK，这就是 JSX ，再来一个例子看看它的具体转译过程！</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 我们用 JSX 是这样写的
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> element <span style="color:#000;font-weight:bold">=</span> (
</span></span><span style="display:flex;"><span>	&lt;<span style="color:#000080">h1</span> <span style="color:#008080">className</span><span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;greeting&#34;</span>&gt;
</span></span><span style="display:flex;"><span>		Hello, world<span style="color:#000;font-weight:bold">!</span>
</span></span><span style="display:flex;"><span>	&lt;/<span style="color:#000080">h1</span>&gt;
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 被 Babel 转译为 React.crateElement() 调用
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> element <span style="color:#000;font-weight:bold">=</span> React.createElement(
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#39;h1&#39;</span>,
</span></span><span style="display:flex;"><span>	{className<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;greeting&#39;</span>},
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#39;Hello, world!&#39;</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// React.createElement() 会预先进行一些检查，实际上创建了如下对象，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 这些对象被称为 “React 元素”，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 注意：这是简化过的结构
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">const</span> element <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>	type<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;h1&#39;</span>,
</span></span><span style="display:flex;"><span>	props<span style="color:#000;font-weight:bold">:</span> {
</span></span><span style="display:flex;"><span>		className<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;greeting&#39;</span>,
</span></span><span style="display:flex;"><span>		children<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;Hello, world!&#39;</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>是的，JSX 就是这么简单 ❗</p>
<h3 id="元素渲染">元素渲染</h3>
<p>在上一节中，我们已经多次提到了 <em>=React “元素”</em> ，它究竟是什么呢？</p>
<p>元素描述了你在屏幕上想看到的内容。如 <code>element</code> 就是一个 React 元素：</p>
<pre tabindex="0"><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
</code></pre><p>与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象（详见上节）。React DOM 会负责更新 DOM 来与 React 元素保持一致。</p>
<p><code>&gt; 那 React DOM 到底是如何渲染 React 元素为 DOM 的呢 ❓</code></p>
<p>只需要把它们传入 <code>ReactDOM.render()</code> 就可以了（该元素会被自动渲染到根 DOM 节点中）！</p>
<p>需要注意的是， <strong>React 元素是不可变对象！</strong> 一旦被创建，你就无法更改它的子元素或者属性。</p>
<p>如何更新 UI 呢？</p>
<p>根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <code>ReactDOM.render()</code>。React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> tick() {
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">const</span> element <span style="color:#000;font-weight:bold">=</span> (
</span></span><span style="display:flex;"><span>		&lt;<span style="color:#000080">div</span>&gt;
</span></span><span style="display:flex;"><span>			&lt;<span style="color:#000080">h1</span>&gt;Hello, world<span style="color:#000;font-weight:bold">!</span>&lt;/<span style="color:#000080">h1</span>&gt;
</span></span><span style="display:flex;"><span>			&lt;<span style="color:#000080">h2</span>&gt;It is {<span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Date</span>().toLocaleTimeString()}.&lt;/<span style="color:#000080">h2</span>&gt;
</span></span><span style="display:flex;"><span>		&lt;/<span style="color:#000080">div</span>&gt;
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>	ReactDOM.render(element, <span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;root&#39;</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 每秒都创建一个新元素，并传入 ReactDOM.render()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>setInterval(tick, <span style="color:#099">1000</span>);
</span></span></code></pre></div><p>当然，在实践中，我们并不会那么蠢，大多数 React 应用只会调用一次 <code>ReactDOM.render()</code>，后续我们将学习如何封装一个有状态的组件。</p>
<h3 id="组件--props">组件 &amp; Props</h3>
<blockquote>
<p>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。</p>
</blockquote>
<p>组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。</p>
<p>在 React 中，有两种组件形式：函数组件和类组件，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 函数组件
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">function</span> Welcome(props) {
</span></span><span style="display:flex;"><span>  	<span style="color:#000;font-weight:bold">return</span> &lt;<span style="color:#000080">h1</span>&gt;Hello, {props.name}&lt;/<span style="color:#000080">h1</span>&gt;;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 类组件
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">class</span> Welcome <span style="color:#000;font-weight:bold">extends</span> React.Component {
</span></span><span style="display:flex;"><span>	render() {
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> &lt;<span style="color:#000080">h1</span>&gt;Hello, {<span style="color:#000;font-weight:bold">this</span>.props.name}&lt;/<span style="color:#000080">h1</span>&gt;;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述两个组件在 React 里是等效的。 <strong>它们返回的都是 React 元素哦！</strong></p>
<blockquote>
<p>= 在实际应用中，函数式组件明显更受欢迎，也更符合直觉，再加上现在有了 Hook，所以你懂得 ……*</p>
</blockquote>
<p>例如，这段代码会在页面上渲染 “Hello, Sara”：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> Welcome(props) {
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> &lt;<span style="color:#000080">h1</span>&gt;Hello, {props.name}&lt;/<span style="color:#000080">h1</span>&gt;;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> element <span style="color:#000;font-weight:bold">=</span> &lt;<span style="color:#000080">Welcome</span> <span style="color:#008080">name</span><span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;Sara&#34;</span> /&gt;;
</span></span><span style="display:flex;"><span>ReactDOM.render(
</span></span><span style="display:flex;"><span>	element,
</span></span><span style="display:flex;"><span>	<span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;root&#39;</span>)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>让我们来回顾一下这个例子中发生了什么：</p>
<ul>
<li>我们调用 <code>ReactDOM.render()</code> 函数，并传入 <code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> 作为参数；</li>
<li>React 调用 Welcome 组件，并将 <code>{name: 'Sara'}</code> 作为 <code>props</code> 传入；</li>
<li>Welcome 组件将 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 元素作为返回值；</li>
<li>React DOM 将 DOM 高效地更新为 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>。</li>
</ul>
<p><strong>注意： 组件名称必须以大写字母开头 ！！！</strong>（React 会将以小写字母开头的组件视为原生 DOM 标签）</p>
<p>组件可以在其输出中引用其他组件（<em>=组件组合</em>）。有时候，将组件拆分为更小的组件也是很不错的选择（<em>=组件提取</em>）。</p>
<p><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></p>
<blockquote>
<p>= 其实，props 很简单，就把它理解为一个只读的函数入参就行了！函数，你足够了解的，对吧？*</p>
</blockquote>
<p>Props 是不可变的，但应用程序的 UI 是动态的，并会伴随着时间的推移而变化，emm&hellip; 😟</p>
<p>放心！在下一章节中，我们将介绍一种新的概念，称之为 “state”。在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p>
<h3 id="state--生命周期">State &amp; 生命周期</h3>
<p>在元素渲染章节中，我们只了解了一种更新 UI 界面的方法，通过调用 <code>ReactDOM.render()</code> 来修改我们想要渲染的元素。</p>
<p>我们也说了，那种方法有点蠢 🤣！ 在本章节中，我们将学习如何封装真正可复用的组件。</p>
<p><strong>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。</strong></p>
<p>下面，让我们看一个完整的 Clock 组件（<code>请留意注释内容</code>）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Clock <span style="color:#000;font-weight:bold">extends</span> React.Component {
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">// 构造函数 - 用来初始化的
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	constructor(props) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">// 将 props 传递到父类的构造函数中 ❓
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// Class 组件应该始终使用 props 参数来调用父类的构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#000;font-weight:bold">super</span>(props);
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">// 在构造函数中为 this.state 赋初值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#000;font-weight:bold">this</span>.state <span style="color:#000;font-weight:bold">=</span> { data<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Date</span>() };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">// 将生命周期方法添加到 Class 中
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// ^ 组件挂载
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		componentDidMount() {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">// 尽管 this.props 和 this.state 是 React 本身设置的，且都拥有特殊的含义，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>			<span style="color:#998;font-style:italic">// 但是其实你可以向 class 中随意添加不参与数据流（比如计时器 ID）的额外字段
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>			<span style="color:#000;font-weight:bold">this</span>.timerID <span style="color:#000;font-weight:bold">=</span> setInterval(() =&gt; <span style="color:#000;font-weight:bold">this</span>.tick(), <span style="color:#099">1000</span> );
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">// ^ 组件卸载
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		componentWillUnmount() {
</span></span><span style="display:flex;"><span>			clearInterval(<span style="color:#000;font-weight:bold">this</span>.timerID);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		tick() {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">// 使用 this.setState() 来时刻更新组件 state
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>			<span style="color:#000;font-weight:bold">this</span>.setState({
</span></span><span style="display:flex;"><span>				date<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">new</span> <span style="color:#0086b3">Date</span>()
</span></span><span style="display:flex;"><span>			});
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		render() {
</span></span><span style="display:flex;"><span>			<span style="color:#000;font-weight:bold">return</span> (
</span></span><span style="display:flex;"><span>				&lt;<span style="color:#000080">div</span>&gt;
</span></span><span style="display:flex;"><span>					&lt;<span style="color:#000080">h1</span>&gt;Hello, world<span style="color:#000;font-weight:bold">!</span>&lt;/<span style="color:#000080">h1</span>&gt;
</span></span><span style="display:flex;"><span>					&lt;<span style="color:#000080">h2</span>&gt;It is {<span style="color:#000;font-weight:bold">this</span>.state.date.toLocaleTimeString()}.&lt;/<span style="color:#000080">h2</span>&gt;
</span></span><span style="display:flex;"><span>				&lt;/<span style="color:#000080">div</span>&gt;
</span></span><span style="display:flex;"><span>			);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReactDOM.render(
</span></span><span style="display:flex;"><span>	&lt;<span style="color:#000080">Clock</span> /&gt;,
</span></span><span style="display:flex;"><span>	<span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;root&#39;</span>)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>让我们来快速概括一下发生了什么和这些方法的调用顺序：</p>
<ol>
<li>当 <code>&lt;Clock /&gt;</code> 被传给 <code>ReactDOM.render()</code> 的时候，React 会调用 <code>Clock</code> 组件的构造函数。因为 <code>Clock</code> 需要显示当前的时间，所以它会用一个包含当前时间的对象来初始化 <code>this.state</code> 。我们会在之后更新 <code>state</code> ；</li>
<li>之后 React 会调用组件的 <code>render()</code> 方法。这就是 React 确定该在页面上展示什么的方式。然后 React 更新 DOM 来匹配 <code>Clock</code> 渲染的输出；</li>
<li>当 <code>Clock</code> 的输出被插入到 DOM 中后，React 就会调用 <code>ComponentDidMount()</code> 生命周期方法。在这个方法中，<code>Clock</code> 组件向浏览器请求设置一个计时器来每秒调用一次组件的 <code>tick()</code> 方法；</li>
<li>浏览器每秒都会调用一次 <code>tick()</code> 方法。 在这方法之中，Clock 组件会通过调用 <code>setState()</code> 来计划进行一次 UI 更新。得益于 <code>setState()</code> 的调用，React 能够知道 <code>state</code> 已经改变了，然后会重新调用 <code>render()</code> 方法来确定页面上该显示什么。这一次，<code>render()</code> 方法中的 <code>this.state.date</code> 就不一样了，如此以来就会渲染输出更新过的时间。React 也会相应的更新 DOM；</li>
<li>一旦 Clock 组件从 DOM 中被移除，React 就会调用 <code>componentWillUnmount()</code> 生命周期方法，这样计时器就停止了。</li>
</ol>
<p><strong>是的！State 就是一个组件的核心！！！</strong> 下面我们来看一下，如何正确的使用它！</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 🅰️ 不要直接修改 State，应该使用 setState()
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 构造函数是唯一可以给 this.state 赋值的地方：
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">this</span>.state.comment <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;Hello&#39;</span>;	<span style="color:#998;font-style:italic">// ❌
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">this</span>.setState({comment<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;Hello&#39;</span>});	<span style="color:#998;font-style:italic">// ✔️
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 🅱️ State 的更新可能是异步的，不要依赖他们的值来更新下一个状态
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">this</span>.setState({
</span></span><span style="display:flex;"><span>  counter<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">this</span>.state.counter <span style="color:#000;font-weight:bold">+</span> <span style="color:#000;font-weight:bold">this</span>.props.increment,
</span></span><span style="display:flex;"><span>});	<span style="color:#998;font-style:italic">// 可能 ❌
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 要解决这个问题，可以让 setState() 接收一个函数而不是一个对象，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">this</span>.setState((state, props) =&gt; ({
</span></span><span style="display:flex;"><span>  counter<span style="color:#000;font-weight:bold">:</span> state.counter <span style="color:#000;font-weight:bold">+</span> props.increment
</span></span><span style="display:flex;"><span>}));	<span style="color:#998;font-style:italic">// ✔️
</span></span></span></code></pre></div><p><strong>数据是向下流动的！</strong></p>
<p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。</p>
<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中。</p>
<h3 id="事件处理">事件处理</h3>
<p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：</p>
<ul>
<li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写；</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串；</li>
<li>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为，你必须显式的使用 <code>preventDefault</code> 。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> ActionLink() {
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">function</span> handleClick(e) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">// 在这里，e 是一个合成事件，React 根据 W3C 规范来定义这些合成事件
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		e.preventDefault();	<span style="color:#998;font-style:italic">// 显式的使用 ✔️
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		console.log(<span style="color:#d14">&#39;The link was clicked.&#39;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> (
</span></span><span style="display:flex;"><span>		&lt;<span style="color:#000080">a</span> <span style="color:#008080">href</span><span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#34;#&#34;</span> <span style="color:#008080">onClick</span><span style="color:#000;font-weight:bold">=</span>{handleClick}&gt;	<span style="color:#998;font-style:italic">// 注意，大括号外不要加引号
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>			Click me
</span></span><span style="display:flex;"><span>		&lt;/<span style="color:#000080">a</span>&gt;
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另外，当你使用 ES6 class 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">class</span> Toggle <span style="color:#000;font-weight:bold">extends</span> React.Component {
</span></span><span style="display:flex;"><span>	constructor(props) {
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">super</span>(props);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">this</span>.state <span style="color:#000;font-weight:bold">=</span> {isToggleOn<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">true</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">// 为了在回调中使用 `this`，这个绑定是必不可少的，否则
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// 当你调用 onClick={this.handleClick} 这个事件函数回调的时候，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// `this` 的值为 `undefined` ，会报错
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#000;font-weight:bold">this</span>.handleClick <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">this</span>.handleClick.bind(<span style="color:#000;font-weight:bold">this</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">// bind 太麻烦 ？试试下面这个等效写法 - class fields 语法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// Create React App 默认启用此语法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// 此语法确保 `handleClick` 内的 `this` 已被绑定
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// 注意：这是 *实验性* 语法
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// handleClick = () =&gt; {
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// 	console.log(&#39;this is:&#39;, this);
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">// }
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	handleClick() {
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">this</span>.setState(state =&gt; ({
</span></span><span style="display:flex;"><span>			isToggleOn<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">!</span>state.isToggleOn
</span></span><span style="display:flex;"><span>		}));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	render() {
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> (
</span></span><span style="display:flex;"><span>		&lt;<span style="color:#000080">button</span> <span style="color:#008080">onClick</span><span style="color:#000;font-weight:bold">=</span>{<span style="color:#000;font-weight:bold">this</span>.handleClick}&gt;
</span></span><span style="display:flex;"><span>			{<span style="color:#000;font-weight:bold">this</span>.state.isToggleOn <span style="color:#000;font-weight:bold">?</span> <span style="color:#d14">&#39;ON&#39;</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;OFF&#39;</span>}
</span></span><span style="display:flex;"><span>		&lt;/<span style="color:#000080">button</span>&gt;
</span></span><span style="display:flex;"><span>		);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReactDOM.render(
</span></span><span style="display:flex;"><span>	&lt;<span style="color:#000080">Toggle</span> /&gt;,
</span></span><span style="display:flex;"><span>	<span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;root&#39;</span>)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>你必须谨慎对待 JSX 回调函数中的 <code>this</code>，在 JavaScript 中，class 的方法默认不会绑定 <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p>
<p>这并不是 React 特有的行为，这其实与 JavaScript 函数工作原理有关。</p>
<blockquote>
<p>= emm&hellip; this 可以说是 JavaScript 永远的痛了，好在应用起来并不算太难！*</p>
</blockquote>
<p>在事件处理中，除了 <code>this</code> 的绑定之外，还有一个需要注意的地方 - 向事件处理程序传递参数。</p>
<p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 id 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span>&lt;<span style="color:#000080">button</span> <span style="color:#008080">onClick</span><span style="color:#000;font-weight:bold">=</span>{(e) =&gt; <span style="color:#000;font-weight:bold">this</span>.deleteRow(id, e)}&gt;Delete Row&lt;/<span style="color:#000080">button</span>&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#000080">button</span> <span style="color:#008080">onClick</span><span style="color:#000;font-weight:bold">=</span>{<span style="color:#000;font-weight:bold">this</span>.deleteRow.bind(<span style="color:#000;font-weight:bold">this</span>, id)}&gt;Delete Row&lt;/<span style="color:#000080">button</span>&gt;
</span></span></code></pre></div><p>上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。</p>
<p>在这两种情况下，<strong>React 的事件对象 <code>e</code> 会被作为第二个参数传递。</strong> 如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h3 id="条件渲染">条件渲染</h3>
<p>这里，就不多讲了，只要记住 JSX 最终会被转成一个 JavaScript 对象，条件渲染也就是 <code>if</code> 或者条件运算符那点事了。</p>
<p>在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 <code>render</code> 方法直接返回 <code>null</code>，而不进行任何渲染。在组件的 <code>render</code> 方法中返回 <code>null</code> 并不会影响组件的生命周期。</p>
<p>想要了解更多，直接阅读 <a href="https://react.docschina.org/docs/conditional-rendering.html">条件渲染</a> 。</p>
<h3 id="列表--key">列表 &amp; Key</h3>
<p>同上，略！</p>
<p>唯一需要注意的是 <code>key</code> ，它是什么？</p>
<p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>
<p><strong>元素的 key 只有放在就近的数组上下文中才有意义。</strong></p>
<blockquote>
<p>= 所谓列表，就是利用一些迭代数据，组装出可用子元素集合，然后把它们放在应该放的父元素中就可以了。*</p>
</blockquote>
<p>详见 <a href="https://react.docschina.org/docs/lists-and-keys.html">列表 &amp; Key</a> 。</p>
<h3 id="表单">表单</h3>
<p>主要是弄清楚 “受控组件” 和 “非受控组件” 的概念，就可以喽。详见 <a href="https://react.docschina.org/docs/forms.html">表单</a> 。</p>
<h3 id="状态提升">状态提升</h3>
<blockquote>
<p>= 抽象和共享，永远不变的真理！</p>
</blockquote>
<blockquote>
<p>通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。</p>
</blockquote>
<p>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state。</p>
<p>更多详见 <a href="https://react.docschina.org/docs/lifting-state-up.html">状态提升</a>。</p>
<h3 id="组合-vs-继承">组合 vs 继承</h3>
<p>详见 <a href="https://react.docschina.org/docs/composition-vs-inheritance.html">组合 vs 继承 – React - react.docschina.org</a>。</p>
<h3 id="react-哲学">React 哲学</h3>
<blockquote>
<p>我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。</p>
</blockquote>
<blockquote>
<p>= emm&hellip; Vue：我才是，Angular：你们都是弟弟！</p>
</blockquote>
<p>OK，上心法 ❤️。</p>
<p><strong>第一步：将设计好的 UI 划分为组件层级</strong></p>
<p><strong>第二步：用 React 创建一个静态版本</strong></p>
<p><strong>第三步：确定 UI state 的 <em>=最小（且完整）表示</em></strong></p>
<p>通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：</p>
<ul>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ul>
<p><strong>第四步：确定 state 放置的位置</strong></p>
<p><strong>第五步：添加反向数据流</strong></p>
<blockquote>
<p>= 基础的核心概念并不多（毕竟就是一个 UI 库嘛），但其思想非常好，官方文档也相当 OK ，可以不定期地多看几遍。</p>
</blockquote>
<h2 id="hook">HOOK</h2>
<blockquote>
<p>= 不着急，先过几遍再说这个，很简单的！*</p>
</blockquote>
<h2 id="相关技术栈">相关技术栈</h2>
<p>当然，你可以选择从零开始，但更好的选择是使用官方提供的脚架 - Create React App 。</p>
<h3 id="样式">样式</h3>
<p>React 对样式如何定义并没有明确态度；如果存在疑惑，比较好的方式是和平时一样，在一个单独的 <code>*.css</code> 文件定义你的样式，并且通过 <code>className</code> 指定它们。</p>
<p><strong>React 并没有原生提供 CSS 封装方案！！！</strong></p>
<p>React 本身的设计原则决定了其不会提供原生的 CSS 封装方案，或者说 CSS 封装并不是 React 框架本身的关注点。因此 ，React 社区从很早的时候就开始寻找相关替代办法。</p>
<pre tabindex="0"><code class="language-__几种技术路线" data-lang="__几种技术路线">- CSS 模块化（CSS Modules）

这种做法非常类似 Angular 与 Vue 对样式的封装方案，其核心是以 CSS 文件模块为单元，将模块内的选择器附上特殊的哈希字符串，以实现样式的局部作用域。对于大多数 React 项目来说，这种方案已经足够用了。

- 基于共识的人工维护的方法论，如 BEM

这种方法的缺点是会为团队带来很大的挑战，对于全局和局部规划选择器的命名，团队对于这种方法需要有共识，即使熟练使用的情况下，在使用中依然有着较高的思维负担和维护成本。

- Shadow DOM

借助 direflow.io 等工具，我们可以将 React 组件输出为 Web Component，借助 Shadow DOM 实现组件的 CSS 样式封装。这是一种解决办法，不过基本很少有项目选择这样做。

- CSS-in-JS
</code></pre><p><em>_1. SCSS</em></p>
<p>好吧，相信你的项目是由 Create React App (CRA) 生成的，如果你想使用 SCSS ，只需要安装 <code>dart-sass</code> 库即可，像下面这样：</p>
<pre tabindex="0"><code>npm i sass --save-dev
</code></pre><p>感谢 <code>node-sass</code> 退出历史舞台，但感谢作者的贡献 😅！</p>
<p>OK，安装之后，就可以把 <code>*.scss</code> 文件作为一个模块引入了，如：</p>
<pre tabindex="0"><code>import example from &#39;./example.scss&#39;;
</code></pre><p><em>_2. CSS in JS</em></p>
<blockquote>
<p>注意此功能并不是 React 的一部分，而是由第三方库提供。</p>
</blockquote>
<p>“CSS-in-JS” 是指一种模式，其中 CSS 由 JavaScript 生成而不是在外部文件中定义。在 <a href="https://github.com/MicheleBertoli/css-in-js">此处</a> 阅读 CSS-in-JS 库之间的对比。</p>
<blockquote>
<p>= CSS in JS 的本质就是写行内样式 style ❓❗*</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-react" data-lang="react"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> style <span style="color:#000;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#39;color&#39;</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;red&#39;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#d14">&#39;fontSize&#39;</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;46px&#39;</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">const</span> clickHandler <span style="color:#000;font-weight:bold">=</span> () =&gt; alert(<span style="color:#d14">&#39;hi&#39;</span>); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ReactDOM.render(
</span></span><span style="display:flex;"><span>	&lt;<span style="color:#000080">h1</span> <span style="color:#008080">style</span><span style="color:#000;font-weight:bold">=</span>{style} <span style="color:#008080">onclick</span><span style="color:#000;font-weight:bold">=</span>{clickHandler}&gt;
</span></span><span style="display:flex;"><span>		Hello, world<span style="color:#000;font-weight:bold">!</span>
</span></span><span style="display:flex;"><span>	&lt;/<span style="color:#000080">h1</span>&gt;,
</span></span><span style="display:flex;"><span>	<span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;example&#39;</span>)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>当然，大项目，这样直接写是非常不明智的，好在有懒人包 🥳！</p>
<p>目前比较流行的两个解决方案是 <a href="https://styled-components.com/">styled-components</a> 和 <a href="https://emotion.sh/docs/introduction">Emotion</a> 。</p>
<p>相关参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/165089496">CSS-in-JS：一个充满争议的技术方案 - 知乎 - zhuanlan.zhihu.com</a></li>
</ul>
<p><em>_3. CSS Modules</em> 🏆（首推）</p>
<blockquote>
<p>这种做法非常类似 Angular 与 Vue 对样式的封装方案，其核心是以 CSS 文件模块为单元，将模块内的选择器附上特殊的哈希字符串，以实现样式的局部作用域。对于大多数 React 项目来说，这种方案已经足够用了。</p>
</blockquote>
<p>由于一般的脚手架都默认集成了 CSS Modules，比如 React 官方的脚手架：create-react-app，已经将 CSS Modules 集成进来了，我们可以直接使用。</p>
<p><strong>如何使用呢？</strong></p>
<p>详见 <a href="https://www.jianshu.com/p/694f9c14ab35">在 React 中使用 CSS Modules</a>。</p>
<h3 id="路由">路由</h3>
<blockquote>
<p>= Hmmm&hellip; 页面路由，大大的有用！</p>
</blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/431389907">react-router-dom 使用指南（最新 V6.0.1） - 知乎 - zhuanlan.zhihu.com</a></li>
<li><a href="https://uprogrammer.cn/react-router-cn/index.html">Introduction · React Router 中文手册 - uprogrammer.cn</a></li>
</ul>
    </div>

    

    

    <div class="container-prevnext">
    <div><a href="https://loveminimal.github.io/posts/canvas/">← Canvas</a></div>
    <div><a href="https://loveminimal.github.io/posts/about-virgo/">♫ 关于 Virgo 需要知道的一些事  →</a></div>
</div>
    
    <div class="container-comment">
	<script src="https://utteranc.es/client.js"
        repo="loveminimal/comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</div>

    
</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    <a href="//beian.miit.gov.cn" target="_blank">
        
        豫ICP备2022002918号-1
        
    </a>
    <a id="s" href="/secrets">&nbsp;</a>
    
</div></div>
    </body>
</html>
