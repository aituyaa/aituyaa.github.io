<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="跨域 - https://loveminimal.github.io/posts/cross-domain/">
    <meta name="author" content="Jack - https://loveminimal.github.io/">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>跨域</title>
    <link rel="icon" type="image/png" href="/favicon.ico">
    
    <link rel="stylesheet" href="https://loveminimal.github.io/style.min.588bdbe244863f48f211eae6ac79640e39689f34e9568c6f2789c5519ab60956.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate ">
        <div id="header"><div class="container-header">
    <div id="vars" class="container-vars" style="display: none;">
	{
		"isSingleColumnOfPostList": true,
		"hasFoldAllCodeBlocks": false,
		"svgColor": "",
		"en": false,
		"dark": false
	}
</div>
    <h1 class="title">
        
            跨域
            
        
    </h1>

    <div class="container-breadcrumb-nav">
    
    <div class="breadcrumb-nav-bar">
        <div><a href="/"><svg t="1656411084410" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2954" width="16" height="16"><path d="M947.5 390.6l-377-290c-34.5-26.5-82.6-26.5-117.1 0l-377 290c-14 10.8-16.6 30.9-5.9 44.9 10.8 14 30.9 16.6 44.9 5.9l28.5-21.9V768c0 88.2 71.8 160 160 160h80c35.3 0 64-28.7 64-64V640c0-17.6 14.4-32 32-32h64c17.6 0 32 14.4 32 32v224c0 35.3 28.7 64 64 64h80c88.2 0 160-71.8 160-160V419.4l28.5 21.9c5.8 4.5 12.7 6.6 19.5 6.6 9.6 0 19.1-4.3 25.4-12.5 10.8-13.9 8.2-34-5.8-44.8zM816 768c0 52.9-43.1 96-96 96h-80V640c0-52.9-43.1-96-96-96h-64c-52.9 0-96 43.1-96 96v224h-80c-52.9 0-96-43.1-96-96V370.2l284.5-218.8c11.5-8.8 27.5-8.8 39 0L816 370.2V768z" fill="#6c757d" p-id="2955"></path></svg></a></div>
        <div><a href="/nav"><svg t="1656411531924" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5827" width="16" height="16"><path d="M849.59197473 125.23018519L139.22930586 391.72854662a23.35052669 23.35052669 0 0 0-14.95414244 21.65490745c-0.12257519 9.70384955 5.61801843 18.46795771 14.40255493 22.04306141l318.42928099 129.25528056 119.51057092 320.39047893c3.06437293 8.23295069 10.35758221 13.89182751 18.7335381 14.87242563l2.7170774 0.14300521a22.79893918 22.79893918 0 0 0 21.20546682-15.36272638l259.51158924-729.54564933a23.8612558 23.8612558 0 0 0-5.31158128-24.55584682 22.3290685 22.3290685 0 0 0-23.9021142-5.43415649zM793.65694081 211.64552314l-196.63064161 552.75171747-91.91077952-246.37564122-253.62799211-102.96295445 542.16941324-203.4131218z" p-id="5828" fill="#6c757d"></path></svg></a></div>
        <div><a href="/search"><svg t="1656411627509" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1730" width="14" height="14"><path d="M469.333333 85.333333c211.968 0 384 172.032 384 384s-172.032 384-384 384-384-172.032-384-384 172.032-384 384-384z m0 682.666667c164.992 0 298.666667-133.674667 298.666667-298.666667 0-165.034667-133.674667-298.666667-298.666667-298.666666-165.034667 0-298.666667 133.632-298.666666 298.666666 0 164.992 133.632 298.666667 298.666666 298.666667z m362.026667 3.029333l120.704 120.661334-60.373333 60.373333-120.661334-120.704 60.330667-60.330667z" p-id="1731" fill="#6c757d"></path></svg></a></div>
        <div><a href="/posts"><svg t="1656411724198" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5655" width="12" height="12"><path d="M811.705761 1024H212.294239c-93.1199 0-174.823046-87.570975-174.823046-187.387854V162.322018C37.471193 69.776145 112.604921 0 212.294239 0H596.190595l7.015883 5.93161c111.74388 95.479788 185.857116 170.741078 279.614824 266.093304 29.65805 30.040735 61.165743 62.122454 96.436499 97.393211l7.271006 7.334787v459.859234c-0.063781 99.816879-81.703145 187.387854-174.823046 187.387854zM212.294239 49.94033c-72.391155 0-124.882716 47.261538-124.882716 112.381688v674.290128c0 71.94469 59.507443 137.383743 124.882716 137.383743h599.411522c65.311492 0 124.882716-65.439053 124.882716-137.383743V397.417876c-32.528184-32.464404-61.73977-62.250016-89.356836-90.377328-90.951355-92.418312-163.278729-165.957521-269.601245-257.163999H212.294239z" fill="#6c757d" p-id="5656"></path><path d="M936.588477 449.526752h-212.326129c-99.753099 0-187.324073-81.703145-187.324073-174.823046V49.94033a25.002055 25.002055 0 0 1 49.94033 0v224.763376c0 65.311492 65.502834 124.882716 137.383743 124.882716h212.326129a25.002055 25.002055 0 1 1 0 49.94033z" fill="#6c757d" p-id="5657"></path></svg></a></div>
        <div><a href="/archive"><svg t="1656411795742" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7334" width="12" height="12"><path d="M884.224 522.24H504.32V141.824c0-16.896-13.824-30.72-30.72-30.72-120.32 0-233.472 47.616-317.952 134.144S26.112 445.952 29.184 566.784c2.56 114.688 49.152 222.72 131.072 304.128 81.92 81.408 189.952 128 304.64 130.56h10.24c117.76 0 227.84-45.568 312.32-128.512 86.528-85.504 133.632-199.68 132.608-321.024-0.512-2.048-1.536-29.696-35.84-29.696z m-140.288 307.712c-74.752 73.728-173.056 112.64-277.504 110.592-205.824-4.608-370.688-169.472-375.296-374.784-3.072-104.448 35.84-202.752 108.544-277.504 65.536-67.072 151.552-107.52 243.712-114.688v378.88c0 16.896 13.824 30.72 30.72 30.72 129.024 0 311.296 0 382.976 0.512-6.144 93.184-46.08 179.712-113.152 246.272z" fill="#6c757d" p-id="7335"></path><path d="M603.136 11.264c-8.192-0.512-15.872 3.072-22.016 8.704-5.632 5.632-9.216 13.824-9.216 22.016v378.88c0 16.896 13.824 30.72 30.72 30.72h378.88c16.896 0 30.72-13.824 30.72-30.72 0-223.744-183.808-407.552-409.088-409.6z m30.208 378.88V74.24c167.424 16.384 301.056 150.016 315.904 315.904h-315.904z" fill="#6c757d" p-id="7336"></path></svg></a></div>
        <div id="light-dark" style="cursor: pointer;"><a><svg t="1656411842215" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5086" width="12" height="12"><path d="M1007.492874 384.513055c-8.795694-34.58307-21.189627-67.666874-36.682043-99.05151-2.698679-5.397358-10.894667-3.498287-10.894666 2.598728v0.299853c0 32.484098-6.896624 63.868734-19.890263 92.554691-10.694764 23.488501-25.487523 45.077933-43.978471 64.068635-41.779547 42.679107-99.05151 66.967217-158.722299 67.26707-61.869712 0.299853-119.941284-24.188159-162.920244-68.966238-40.280281-41.979449-62.56937-98.251902-62.269516-156.323473 0.399804-59.270984 23.588452-114.94373 65.567901-156.823229 19.59041-19.59041 42.179351-35.082826 66.667364-46.077443C672.956643 71.166451 704.041426 64.469729 736.125719 64.469729h1.299364c6.097015 0 8.096037-8.096037 2.598728-10.794715C708.739126 37.982696 675.655322 25.488812 641.172203 16.493216 599.492607 5.598549 555.714038-0.098662 510.536154 0.001289 222.37722 0.700947-7.41029 237.38508 0.185992 525.444064c7.096526 271.667008 225.889418 490.559851 497.456474 497.856279 287.559228 7.796183 524.14341-220.891864 525.842579-508.551044 0.299853-44.977981-5.297407-88.656599-15.992171-130.236244z m-83.15929 301.552378c-22.588942 53.27392-54.873137 101.250434-95.953027 142.330323-41.179841 41.179841-89.056403 73.464036-142.330324 95.953027-55.172991 23.288599-113.744317 35.182777-174.314666 35.182777s-119.141675-11.794226-174.314666-35.182777c-53.27392-22.588942-101.250434-54.873137-142.330323-95.953027-41.179841-41.179841-73.464036-89.056403-95.953027-142.330323C75.749001 630.892442 63.954774 572.221164 63.954774 511.750767s11.794226-119.141675 35.182777-174.314666c22.588942-53.27392 54.873137-101.250434 95.953027-142.330323 41.179841-41.179841 89.056403-73.464036 142.330323-95.953027C392.593892 75.7642 451.26517 63.969974 511.735567 63.969974c13.99315 0 27.886348 0.599706 41.679596 1.89907C489.246577 118.643209 448.266638 198.704016 448.266638 288.360126c0 159.022152 128.836929 287.859081 287.859081 287.859081 89.156354 0 168.817357-40.580134 221.691473-104.149015 1.099462 13.09359 1.699168 26.387082 1.699168 39.680575 0 60.470397-11.794226 119.141675-35.182776 174.314666z" p-id="5087" fill="#6c757d"></path></svg></a></div>
        
    </div>

    
</div>

            <div id="toc">📜</div>
        
    
    
</div>
</div>
        <div id="content">















<div class="container-main 
     container-page 
">

    <div class="desc">
        
        <span>
            
            <svg t="1656736000388" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7409" width="12" height="12"><path d="M524.885333 338.986667L200.362667 663.466667c-17.28 15.274667-27.989333 36.693333-29.696 56.234666v133.76l130.730666 0.085334c22.784-1.621333 43.989333-12.245333 61.013334-31.701334l322.688-322.645333-160.213334-160.213333z m60.373334-60.330667l160.170666 160.213333 102.144-102.144a19.712 19.712 0 0 0 0-27.861333L715.093333 176.426667a19.456 19.456 0 0 0-27.605333 0L585.258667 278.613333zM701.312 85.333333c27.946667 0 54.741333 11.136 74.282667 30.848l132.309333 132.309334a105.045333 105.045333 0 0 1 0 148.565333L424.874667 879.957333c-29.824 34.346667-72.106667 55.466667-120.448 58.794667H85.333333v-42.666667l0.128-179.84c3.626667-44.970667 24.576-86.826667 56.448-114.944l485.12-485.034666A104.789333 104.789333 0 0 1 701.269333 85.333333z" p-id="7410" fill="#adb5bd"></path></svg>
            2020-11-03&nbsp;
        </span>
        <span>
            
            <svg t="1656737270708" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23838" width="11" height="11"><path d="M824.264 95.36c0-23.859 25.043-44.16 48.902-44.16s49.714 20.301 49.714 44.16v190.08c0 23.859-19.054 52.868-42.913 52.868h-190.08c-23.859 0-46.696-25.96-46.696-49.819s22.55-46.249 46.409-46.249h82.025C702.344 175.534 610.22 155.853 512 155.853c-206.775 0-360.398 149.372-360.398 356.147 0 206.775 153.623 358.23 360.398 358.23 206.775 0 357.467-151.455 357.467-358.23 0-23.859 23.634-50.706 53.413-50.706 29.78 0 49.92 26.847 49.92 50.706 0 254.493-206.307 460.8-460.8 460.8-254.493 0-460.8-206.307-460.8-460.8C51.2 257.507 257.507 51.2 512 51.2c122.4 0 226.684 33.296 312.264 117.369 0.358 0.351 0.358-24.052 0-73.209z" p-id="23839" fill="#adb5bd"></path></svg>
            2023-05-09&nbsp;&nbsp;&nbsp;
        </span>
        <span>
            
            <svg t="1656737548689" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="33866" width="12" height="12"><path d="M832.038608 64.662657H192.030028C121.255125 64.662657 63.940169 121.98845 63.940169 192.694717v446.793671C63.940169 710.205493 121.255125 767.643272 192.030028 767.643272h133.353183a63.940169 63.940169 0 0 1 55.219742 31.576328l76.099638 129.83828c12.358154 21.093031 33.790754 31.626903 55.216129 31.626903s42.832688-10.544709 55.198067-31.619678l76.222461-129.870792a63.940169 63.940169 0 0 1 55.212517-31.551041h133.54103c70.576219 0 127.732228-57.289669 127.732227-127.800865V192.391272C959.825022 121.85479 902.643727 64.662657 832.038608 64.662657zM895.884854 639.842407A63.85347 63.85347 0 0 1 832.092795 703.703103h-133.54103a127.753903 127.753903 0 0 0-110.349172 63.09847l-76.222461 129.856342a0.274545 0.274545 0 0 1 0-0.050574h-0.032512s-0.021675 0.061411-0.032512 0.061412l-76.1466-129.85273A127.804477 127.804477 0 0 0 325.383211 703.703103H192.030028A64.207489 64.207489 0 0 1 127.880338 639.488388V192.694717A64.102729 64.102729 0 0 1 192.030028 128.602826h640.00858A63.799284 63.799284 0 0 1 895.884854 192.391272v447.451135z" fill="#adb5bd" p-id="33867"></path><path d="M608.154093 288.092004A31.970084 31.970084 0 0 0 576.184009 320.062089v160.078006l-134.650049-179.278119A31.970084 31.970084 0 0 0 384.002258 320.062089v255.760676a31.970084 31.970084 0 0 0 63.940169 0v-159.958796l134.650048 179.274507a31.970084 31.970084 0 0 0 57.531703-19.200113V320.062089a31.970084 31.970084 0 0 0-31.970085-31.970085z" fill="#adb5bd" p-id="33868"></path></svg>
            5979 字</span>&nbsp;
        <span>
            
            <svg t="1656737462334" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="32892" width="12" height="12"><path d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z" p-id="32893" fill="#adb5bd"></path><path d="M695.466667 567.466667l-151.466667-70.4V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666l170.666667 81.066667c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8 0 23.466667-6.4 29.866666-19.2 6.4-14.933333 0-34.133333-17.066666-42.666666z" p-id="32894" fill="#adb5bd"></path></svg>
            12 分钟</span>
            <div class="container-ctgtag">
	<div class="taxonomy">
		
		<div class="ctg">
			
			
			<a href="/categories/javascript">JavaScript</a>
			
		</div>
		<div class="tag">
			
			
			
		</div>
	</div>
</div>
        
    </div>
    
    <div class="toc">
        
        <div class="page-operation">
            <div><a href="#"><img src="/imgs/icons/arrow-up-circle.svg" alt=""></a></div>
            <div><a href="https://loveminimal.github.io/posts/drag-and-drop/"><img src="/imgs/icons/arrow-left-circle.svg" alt=""></a></div>
            <div><a href="https://loveminimal.github.io/posts/wubi/"><img src="/imgs/icons/arrow-right-circle.svg" alt=""></a></div>
        </div>
        
        <nav id="TableOfContents">
  <ul>
    <li><a href="#什么是跨域">什么是跨域</a></li>
    <li><a href="#cookie">Cookie</a></li>
    <li><a href="#iframe">iframe</a>
      <ul>
        <li><a href="#片段识别符">片段识别符</a></li>
        <li><a href="#windowname">window.name</a></li>
        <li><a href="#windowpostmessage">window.postMessage</a></li>
      </ul>
    </li>
    <li><a href="#ajax">AJAX</a>
      <ul>
        <li><a href="#jsonp">JSONP</a></li>
        <li><a href="#websocket">WebSocket</a></li>
        <li><a href="#cors">CORS</a></li>
      </ul>
    </li>
    <li><a href="#cors-详解">CORS 详解</a>
      <ul>
        <li><a href="#两种请求">两种请求</a></li>
        <li><a href="#简单请求">简单请求</a></li>
        <li><a href="#非简单请求">非简单请求</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>

    <div class='content  content '>
        <p>🔔 本文摘录自 <a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a></p>
<h2 id="什么是跨域">什么是跨域</h2>
<p>跨域，是指浏览器不能执行其他网站的脚本，它是浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制。</p>
<p>那么，什么是同源策略呢？</p>
<p>同源策略，是由 Netscape 公司于 1995 年引入浏览器的，目前，所有浏览器都实行这个策略。</p>
<p>为什么需要同源策略呢？</p>
<p>同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<blockquote>
<p>= 每一件事物都有其产生的源头……</p>
</blockquote>
<p>最初，它的含义是，A 网页设置的 Cookie ，B 网页不能打开，除非这两个网页“同源” &ndash; 协议相同、域名相同、端口相同。</p>
<blockquote>
<p>= Cookie 往往用来保存用户的登录状态，所以“同源策略”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
</blockquote>
<p>随着互联网的发展，“同源策略”越来越严格。目前，如果非同源，共有三种行为受到限制：</p>
<ol>
<li>Cookie、LocalStorage 和 IndexDB 无法读取；</li>
<li>DOM 无法获得；</li>
<li>AJAX 请求不能发送。</li>
</ol>
<p>跨域的限制当然是有必要的，但实际应用过程中也常常需要在保证相对安全的情况下规避上述的三种限制。</p>
<blockquote>
<p>= 往往是这样，建立的束缚就是用来打挣脱的…… 在同源策略不允许跨域的那一刻，也就产生了需要跨域的需求。</p>
</blockquote>
<h2 id="cookie">Cookie</h2>
<p>Cookie 是服务器写入浏览器的一小段信息 ，只有同源网页才能共享。但是，如果两个网页的一级域名相同，只是二级域名不同，浏览器允许通过设置 =document.domain= 共享 Cookie 。</p>
<blockquote>
<p>*注：Cookie 是服务器写入浏览器的信息哦！</p>
</blockquote>
<p>举例来说，A 网页是 <code>http://w1.example.com/a.html</code> ，B 网页是 <code>http://w2.example.com/b.html</code> ，那么只要设置相同的 <code>document.domain</code> ，两个网页就可以共享 Cookie 。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#0086b3">document</span>.domain <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;example.com&#39;</span>;
</span></span></code></pre></div><p>现在，A 网页通过脚本设置一个 Cookie ：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#0086b3">document</span>.cookie <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;test1=hello&#39;</span>;
</span></span></code></pre></div><p>B 网页就可以读到这个 Cookie ：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> allCookie <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">document</span>.cookie;
</span></span></code></pre></div><p>*注：这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法（要使用 PostMessage API）。</p>
<p>另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如 <code>.example.com</code> ：</p>
<pre tabindex="0"><code>Set-Cookie: key=value; domain=.example.com; path=/
</code></pre><p>如此，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie 。</p>
<blockquote>
<p>= 旨在理解吧，已经是被时代淘汰了的东东了……</p>
</blockquote>
<h2 id="iframe">iframe</h2>
<p>如果两个网页不同源，就无法拿到对方的 DOM ，典型的例子是 <code>iframe</code> 窗口和 <code>window.open</code> 方法打开的窗口，它们与父窗口无法通信。</p>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置 <code>document.domain</code> 属性，就可以规避同源策略，拿到 DOM 。</p>
<p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题：</p>
<ul>
<li>片段识别符（fragment identifier）；</li>
<li>window.name ；</li>
<li>跨文档通信 API （Cross-document messaging）。</li>
</ul>
<h3 id="片段识别符">片段识别符</h3>
<p>片段识别符 （fragment identifier），是指 URL 的 <code>#</code> 号后面的部分，如 <code>http://example.com/x.html#fragment</code> 的 <code>#fragment</code> 。如果，只是改变片段识别符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段识别符，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> src <span style="color:#000;font-weight:bold">=</span> originURL <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#39;#&#39;</span> <span style="color:#000;font-weight:bold">+</span> data;
</span></span><span style="display:flex;"><span><span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;myIFrame&#39;</span>).src <span style="color:#000;font-weight:bold">=</span> src;
</span></span></code></pre></div><p>子窗口通过监听 <code>hashchange</code> 事件得到通知，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#0086b3">window</span>.onhashchange <span style="color:#000;font-weight:bold">=</span> checkMessage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> checkMessage() {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">var</span> message <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">window</span>.location.hash;
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>}
</span></span></code></pre></div><p>同样的，子窗口也可以改变父窗口的片段标识符：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>parent.location.href <span style="color:#000;font-weight:bold">=</span> target <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#39;#&#39;</span> <span style="color:#000;font-weight:bold">+</span> hash;
</span></span></code></pre></div><h3 id="windowname">window.name</h3>
<p>浏览器窗口有 <code>window.name</code> 属性，它的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取它。</p>
<p>来看一个具体的例子吧。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入 <code>window.name</code> 属性，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#0086b3">window</span>.name <span style="color:#000;font-weight:bold">=</span> data;
</span></span></code></pre></div><p>接着，子窗口跳回一个与主窗口同域的网址：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>location <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;http://parent.url.com/xxx.html&#39;</span>;
</span></span></code></pre></div><p>然后，主窗口就可以读取子窗口的 <code>window.name</code> 了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> data <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">document</span>.getElementById(<span style="color:#d14">&#39;myFrame&#39;</span>).contentWindow.name;
</span></span></code></pre></div><p>这种方法的优点是， <code>window.name</code> 容量很大，可以放置非常长的字符串；缺点是必须监听子窗口 <code>window.name</code> 属性的变化，影响网页性能。</p>
<blockquote>
<p>= 不强制兼容 IE 的话，实在不想碰这玩意儿。..</p>
</blockquote>
<h3 id="windowpostmessage">window.postMessage</h3>
<p>片段识别符和 <code>window.name</code> 两种方法都属于破解，HTML5 为了解决这个问题，引入了一个全新的 API &ndash; 跨文档通信 API （Cross-document messaging）。</p>
<blockquote>
<p>= 所谓破解，就是把公鸡的工作交给大鹅去做，虽然也能叫你起床，但总归不那么悦耳。</p>
</blockquote>
<p>这个 API 为 <code>window</code> 对象新增了一个 <code>window.postMessage</code> 方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>父窗口 <code>http://aaa.com</code> 向子窗口 <code>http://bbb.com</code> 发消息，调用 <code>postMessage</code> 方法就可以了，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> popup <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">window</span>.open(<span style="color:#d14">&#39;http://bbb.com&#39;</span>, <span style="color:#d14">&#39;title&#39;</span>);
</span></span><span style="display:flex;"><span>popup.postMessage(<span style="color:#d14">&#39;Hello World!&#39;</span>, <span style="color:#d14">&#39;http://bbb.com&#39;</span>);
</span></span></code></pre></div><p>其中， <code>postMessage</code> 方法的：</p>
<ul>
<li>第一个参数是具体的信息内容；</li>
<li>第二个参数是接收消息的窗口的源（origin），即“协议+域名+端口”，也可以设为 <code>*</code> ，表示不限制域名，向所有窗口发送。</li>
</ul>
<p>子窗口向父窗口发送消息的写法类似：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#0086b3">window</span>.opener.postMessage(<span style="color:#d14">&#39;Nice to see you&#39;</span>, <span style="color:#d14">&#39;http://aaa.com&#39;</span>);
</span></span></code></pre></div><p>父窗口和子窗口都可以通过 <code>message</code> 事件，监听对方的消息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#0086b3">window</span>.addEventListener(
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#39;message&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">function</span> (e) {
</span></span><span style="display:flex;"><span>        console.log(e.data);
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><blockquote>
<p><code>message</code> 事件的事件对象 <code>event</code> ，提供了以下三个属性：</p>
<ul>
<li><code>event.source</code> ：发送消息的窗口；</li>
<li><code>event.origin</code> ：消息发向的网址；</li>
<li><code>event.data</code> ：消息内容。</li>
</ul>
</blockquote>
<p>下面的例子是，子窗口通过 <code>event.source</code> 属性引用父窗口，然后发消息，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#0086b3">window</span>.addEventListener(<span style="color:#d14">&#39;message&#39;</span>, receiveMessage);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> receiveMessage(event) {
</span></span><span style="display:flex;"><span>    event.source.postMessage(<span style="color:#d14">&#39;Nice to see you!&#39;</span>, <span style="color:#d14">&#39;*&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>event.origin</code> 属性可以过滤不是发给本窗口的消息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#0086b3">window</span>.addEventListener(<span style="color:#d14">&#39;message&#39;</span>, receiveMessage);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> receiveMessage(event) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (event.origin <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;http://aaa.com&#39;</span>) <span style="color:#000;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (event.data <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#39;Hello World&#39;</span>) {
</span></span><span style="display:flex;"><span>        event.source.postMessage(<span style="color:#d14">&#39;Hello&#39;</span>, event.origin);
</span></span><span style="display:flex;"><span>    } <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        console.log(event.data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过 <code>window.postMessage</code> ，读写其他窗口的 LocalStorage 也成为了可能。</p>
<blockquote>
<p>= 其实吧，只要是能序列化字符串的信息，都可以传递。</p>
</blockquote>
<p>例如，主窗口写入 iframe 子窗口的 <code>localStorage</code> ：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#0086b3">window</span>.onmessage <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> (e) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (e.origin <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;http://bbb.com&#39;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">var</span> payload <span style="color:#000;font-weight:bold">=</span> JSON.parse(e.data);
</span></span><span style="display:flex;"><span>    localStorage.setItem(payload.key, JSON.stringfy(payload.data)); <span style="color:#998;font-style:italic">// ?? payload.data
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><p>其中，父窗口发送消息的代码如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> win <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">document</span>.getElementByTagName(<span style="color:#d14">&#39;iframe&#39;</span>)[<span style="color:#099">0</span>].contentWindow;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> obj <span style="color:#000;font-weight:bold">=</span> { name<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;Jack&#39;</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>win.postMessage(JSON.stringfy({ key<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;storage&#39;</span>, data<span style="color:#000;font-weight:bold">:</span> obj }), <span style="color:#d14">&#39;http://bbb.com&#39;</span>);
</span></span></code></pre></div><blockquote>
<p>= 下面来个加强版的。..</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 加强版的父窗口发消息 ///
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">var</span> win <span style="color:#000;font-weight:bold">=</span> doucment.getElementByTagName(<span style="color:#d14">&#39;iframe&#39;</span>)[<span style="color:#099">0</span>].contentWindow;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> obj <span style="color:#000;font-weight:bold">=</span> { name<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;Jack&#39;</span> };
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 存入对象
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>win.postMessage(
</span></span><span style="display:flex;"><span>    JSON.stringfy({ key<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;storage&#39;</span>, method<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;set&#39;</span>, data<span style="color:#000;font-weight:bold">:</span> obj }),
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#39;http://bbb.com&#39;</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 读取对象
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>win.postMessage(JSON.stringfy({ key<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;storage&#39;</span>, method<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;get&#39;</span> }), <span style="color:#d14">&#39;*&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">window</span>.onmessage <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> (e) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (e.origin <span style="color:#000;font-weight:bold">!=</span> <span style="color:#d14">&#39;http://aaa.com&#39;</span>) <span style="color:#000;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    console.log(JSON.parse(e.data).name); <span style="color:#998;font-style:italic">// → &#34;Jack&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 加强版的子窗口接收消息 ///
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span><span style="color:#0086b3">window</span>.onmessage <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> (e) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> (e.origin <span style="color:#000;font-weight:bold">!==</span> <span style="color:#d14">&#39;http://bbb.com&#39;</span>) <span style="color:#000;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">var</span> payload <span style="color:#000;font-weight:bold">=</span> JSON.parse(e.data);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">switch</span> (payload.method) {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#d14">&#39;set&#39;</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            localStorage.setItem(payload.key, JSON.stringfy(payload.data));
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#d14">&#39;get&#39;</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">var</span> parent <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">window</span>.parent;
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">var</span> data <span style="color:#000;font-weight:bold">=</span> localStorage.getItem(payload.key);
</span></span><span style="display:flex;"><span>            parent.postMessage(data, <span style="color:#d14">&#39;http://aaa.com&#39;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">case</span> <span style="color:#d14">&#39;remove&#39;</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            localStorage.removeItem(payload.key);
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p>= 从本质上来说，这几种方法都是利用浏览器的某些信息保留机制，把信息序列化为字符串，以参数形式在跨域窗口之间的传递。</p>
</blockquote>
<h2 id="ajax">AJAX</h2>
<p>浏览器的同源策略规定， AJAX 请求只能发给同源的网址 ，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制： JSONP、WebSocket、CORS 。</p>
<blockquote>
<p>= 这里架设的服务器是用来代理客户端的，是正向代理。</p>
</blockquote>
<h3 id="jsonp">JSONP</h3>
<p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<blockquote>
<p>很简单，但缺点在于 JSONP 只支持 <code>GET</code> 请求。</p>
</blockquote>
<p>JSONP 的基本思想是什么？</p>
<p>原来，网页通过添加一个 <code>&lt;script&gt;</code> 元素，向服务器请求 JSON 数据的做法是不受同源策略限制的；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<blockquote>
<p>= 通过 <code>script</code> 标签的 <code>src</code> 属性值作为请求地址，666 。</p>
</blockquote>
<p>首先，网页动态插入 <code>&lt;script&gt;</code> 元素，由它向跨源网址发出请求，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> addScriptTag(src) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">var</span> script <span style="color:#000;font-weight:bold">=</span> doucment.createElement(<span style="color:#d14">&#39;script&#39;</span>);
</span></span><span style="display:flex;"><span>    script.setAttribute(<span style="color:#d14">&#39;type&#39;</span>, <span style="color:#d14">&#39;text/javascript&#39;</span>);
</span></span><span style="display:flex;"><span>    script.src <span style="color:#000;font-weight:bold">=</span> src;
</span></span><span style="display:flex;"><span>    <span style="color:#0086b3">document</span>.body.appendChild(script);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">window</span>.onload <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    addScriptTag(<span style="color:#d14">&#39;http://example.com/jp?callback=foo&#39;</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">function</span> foo(data) {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;Your public IP address is: &#39;</span> <span style="color:#000;font-weight:bold">+</span> data.ip);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述代码通过动态添加 <code>&lt;script&gt;</code> 元素，向服务器 <code>example.com</code> 发出请求。</p>
<p>*注：该请求的查询字符串有一个 <code>callback</code> 参数，用来指定回调函数的名字，在对于 JSONP 是必需的。</p>
<p>服务器收到这个请求后，会将数据放在回调函数的参数位置返回，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>foo({
</span></span><span style="display:flex;"><span>    ip<span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#39;8.8.8.8&#39;</span>,
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>由于 <code>&lt;script&gt;</code> 元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了 <code>foo</code> 函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用 <code>JSON.parse</code> 的步骤。</p>
<h3 id="websocket">WebSocket</h3>
<p>WebSocket 是一种通信协议，使用 <code>ws://</code> （非加密）和 <code>wss://</code> （加密）作为协议前缀。该协议 不实行同源策略 ，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>来看个例子，下面是浏览器发出的 WebSocket 请求的头信息：</p>
<pre tabindex="0"><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</code></pre><p>其中， <code>Origin</code> 表示该请求的请求源（origin），即发自哪个域名。</p>
<blockquote>
<p>*注：正是因为有了 <code>Origin</code> 这个字段，WebSocket 才没有实行同源策略，因为服务器可以根据这个字段，判断是否允许本次通信。</p>
</blockquote>
<p>如果该域名在白名单内，服务器就会做出如下响应：</p>
<pre tabindex="0"><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre><h3 id="cors">CORS</h3>
<p>CORS （Cross-Origin Resource Sharing）是跨域资源分享的缩写，它是 W3C 标准，是 跨源 AJAX 请求的根本解决办法。相比 JSONP 只能发 <code>GET</code> 请求，CORS 允许任何类型的请求。</p>
<h2 id="cors-详解">CORS 详解</h2>
<p>CORS 允许浏览器向跨源服务器，发出 <code>XMLHttpRequest</code> 请求，从而克服了 AJAX 只能同源使用的限制。接下来，我们来深入认识下 CORS 的内部机制。</p>
<p>CORS 需要浏览器和服务器同时支持， 整个 CORS 通信过程，都是浏览器自动完成 ，不需要用户参与。</p>
<blockquote>
<p>对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求资源，就会自动添加一些附加的头信息 ，有时还会多出一次附加的请求，但用户不会有感觉。</p>
</blockquote>
<blockquote>
<p>= 浏览器是个好宿主，直接帮你（用户）解决了。本质上讲，CORS 在浏览器端而言，就是浏览器对用户的 AJAX 请求的“封装代理”。</p>
</blockquote>
<p>因此，实现 CORS 通信的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信。</p>
<h3 id="两种请求">两种请求</h3>
<p>浏览器将 CORS 请求分为两类： 简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两在条件，就属于简单请求，如下：</p>
<ul>
<li>请求方法是以下三种之一： <code>HEAD、GET、POST</code> ；</li>
<li>HTTP 的头信息不超出以下几种字段：</li>
</ul>
<pre tabindex="0"><code>- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type
</code></pre><p>其中， <code>Content-Type</code> 只限于三个值 <code>application/x-www-form-urlencode、multipart/form-data、text/plain</code> 。</p>
<p>这是为了兼容表单，因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p>
<p>*注：凡是不同时满足上面两个条件，就属于非简单请求，浏览器对这两种请求的处理，是不一样的。</p>
<h3 id="简单请求">简单请求</h3>
<p><strong>1. 基本流程</strong></p>
<p>对于简单请求，浏览器直接发出 CORS 请求，具体来说，就是在头信息中，增加一个 <code>Origin</code> 字段。</p>
<p>如下面这个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息中，添加一个 <code>Origin</code> 字段：</p>
<pre tabindex="0"><code>GET /cors HTTP/1.1
Origin: http://api.bob.com ←
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre><p>上面的头信息中， <code>Origin</code> 字段用来说明，本次请求来自哪个源（协议+域名+端口），服务器根据这个值决定是否同意这次请求。</p>
<p>1.1 不在服务器许可范围内</p>
<p>如果 <code>Origin</code> 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现这个回应的头信息没有包含 <code>Access-Control-Allow-Origin</code> 字段，就知道出错了，从面抛出一个错误，被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调函数捕获。</p>
<p>*注：这种错误无法通过状态码识别，因为 HTTP 回应的状态码可能是 200 。</p>
<p>1.2 在服务器许可范围内</p>
<p>如果 <code>Origin</code> 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段，如下：</p>
<pre tabindex="0"><code>Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
</code></pre><p>上面的信息头中，有三个与 CORS 请求相关的字段，都以 <code>Access-Control-</code> 开头。</p>
<p>（1）Access-Control-Allow-Origin</p>
<p>该字段是必须的，它的值要么是请求时 <code>Origin</code> 字段的值，要么是一个 <code>*</code> （表示接受任意域名的请求）。</p>
<p>（2）Access-Control-Allow-Credentials</p>
<p>该字段可选，它的值是一个布尔值，表示是否允许发送 Cookie 。</p>
<p>默认情况下，Cookie 不包括在 CORS 请求之中，设为 <code>true</code> ，即表示服务器明确许可 Cookie 可以包含在请求中，一起发给服务器。</p>
<p>*注：其实，这个值也只能设为 <code>true</code> ，如果服务器不要浏览器发送 Cookie ，删除该字段即可。</p>
<p>（3）Access-Control-Expose-Headers</p>
<p>该字段可选，CORS 请求时， <code>XMLHttpRequest</code> 对象的 <code>getResponseHeader()</code> 方法只能拿到 6 个基本字段： <code>Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma</code> 。如果想拿到其他字段，就必须在 <code>Access-Control-Expose-Headers</code> 里面指定。如下面的例子中就指定了 <code>FooBar</code> ，如此便可以通过 <code>getResponseHeader('FooBar')</code> 来返回 <code>FooBar</code> 字段的值。</p>
<p><strong>2. withCredentials 属性</strong></p>
<p>上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 <code>Access-Control-Allow-Credentials</code> 字段：</p>
<pre tabindex="0"><code>Access-Control-Allow-Credentials: true
</code></pre><p>另一方面，开发者必须在 AJAX 请求中打开 <code>withCredentials</code> 属性，如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> xhr <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> XMLHttpRequest();
</span></span><span style="display:flex;"><span>xhr.withCredentials <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">true</span>;
</span></span></code></pre></div><p>否则，即使服务器同意发送 Cookie ，浏览器也不会发送。或者，服务器要求设置 Cookie ，浏览器也不会处理。</p>
<p>但是，如果省略 <code>withCredentials</code> 设置，有的浏览器还是会一起发送 Cookie 。这时，可以显式关闭 <code>withCredentials</code> ：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>xhr.withCredentials <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">false</span>;
</span></span></code></pre></div><p>需要注意的是，如果要发送 Cookie ， <code>Access-Control-Allow-Origin</code> 就不能设为星号，必须指定的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 <code>document.cookie</code> 也无法读取服务器域名下的 Cookie 。</p>
<h3 id="非简单请求">非简单请求</h3>
<ol>
<li>预检请求</li>
</ol>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code> ，或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code> 。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为预检请求（prefight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 <code>XMLHttpRequest</code> 请求，否则就报错。</p>
<p>来看一段浏览器的 JavaScript 脚本。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> url <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39;http://api.alice.com/cors&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> xhr <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> XMLHttpReuqest();
</span></span><span style="display:flex;"><span>xhr.open(<span style="color:#d14">&#39;PUT&#39;</span>, url, <span style="color:#000;font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>xhr.setRequestHeader(<span style="color:#d14">&#39;X-Custom-Header&#39;</span>, <span style="color:#d14">&#39;value&#39;</span>);
</span></span><span style="display:flex;"><span>xhr.send();
</span></span></code></pre></div><p>上面代码中，HTTP 请求的方法是 <code>PUT</code> ，并且发送一个自定义头信息 <code>X-Custom-Header</code> 。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息：</p>
<pre tabindex="0"><code>OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre><p>“预检”请求用的请求方法是 <code>OPTIONS</code> ，表示这个请求是用来询问的。头信息里面，关键字段是 <code>Origin</code> ，表示请求来自哪个源。</p>
<p>除了 <code>Origin</code> 字段，“预检”请求的头信息包括两个特殊字段。</p>
<p>（1）Access-Control-Request-Method</p>
<p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 <code>PUT</code> 。</p>
<p>（2）Access-Control-Request-Headers</p>
<p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求额外发送的头信息字段，上例是 <code>X-Custom-Header</code> 。</p>
<ol start="2">
<li>预检请求的回应</li>
</ol>
<p>服务器收到“预检”请求以后，检查了 <code>Origin、Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> 字段以后，确认允许跨源请求，就可以做出反应。</p>
<pre tabindex="0"><code>HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
</code></pre><p>上面的 HTTP 回应中，关键的是 <code>Access-Control-Allow-Origin</code> 字段，表示 <code>http://api.bob.com</code> 可以请求数据。该字段可也可以设为星号，表示同意任意跨源请求。</p>
<pre tabindex="0"><code>Access-Control-Allow-Origin: *
</code></pre><p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意“预检”请求，因此触发一个错误，被 <code>XMLHttpRequest</code> 对象的 <code>onerror</code> 回调函数捕获，控制台会打印出如下的报错信息：</p>
<pre tabindex="0"><code>XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</code></pre><p>服务器回应的其他 CORS 相关字段如下：</p>
<pre tabindex="0"><code>Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
</code></pre><p>（1）Access-Control-Allow-Methods</p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。</p>
<p>*注：返回的是所有支持的方法，而不单是浏览器请求的那个方法，这是为了避免多次“预检”请求。</p>
<p>（2）Access-Control-Allow-Headers</p>
<p>如果浏览器请求包括 <code>Access-Control-Request-Headers</code> 字段，则 <code>Access-Control-Allow-Headers</code> 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。</p>
<p>（3）Access-Control-Allow-Credentials</p>
<p>该字段与简单请求时的含义相同。</p>
<p>（4）Access-Control-Max-Age</p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒，在些期间，不用发出另一条预检请求。</p>
<ol>
<li>浏览器的正常请求和回应</li>
</ol>
<p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 <code>Origin</code> 头信息字段。服务器的回应，也都会有一个 <code>Access-Control-Allow-Origin</code> 头信息字段。</p>
<p>下面是“预检”请求之后，浏览器的正常 CORS 请求：</p>
<pre tabindex="0"><code>PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre><p>上面头信息的 <code>Origin</code> 字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应：</p>
<pre tabindex="0"><code>Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
</code></pre><p>上面头信息中， <code>Access-Control-Allow-Origin</code> 字段是每次回应都必定包含的。</p>
    </div>

    

    

    <div class="container-prevnext">
    <div><a href="https://loveminimal.github.io/posts/drag-and-drop/">← Drag and Drop</a></div>
    <div><a href="https://loveminimal.github.io/posts/wubi/">五笔那些事儿  →</a></div>
</div>
    
    <div class="container-comment">
	<script src="https://utteranc.es/client.js"
        repo="loveminimal/comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</div>

    
</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    <a href="//beian.miit.gov.cn" target="_blank">
        
        豫ICP备2022002918号-1
        
    </a>
    <a id="s" href="/secrets">&nbsp;</a>
    
</div></div>
    </body>
</html>
